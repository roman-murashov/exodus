#include "MegaDriveROMLoader.h"
#include "FileOpenMenuHandler.h"
#include "Stream/Stream.pkg"
#include "HeirarchicalStorage/HeirarchicalStorage.pkg"
#include <commctrl.h>
#include <shlwapi.h>
#include <shlobj.h>

//----------------------------------------------------------------------------------------
//Constructors
//----------------------------------------------------------------------------------------
MegaDriveROMLoader::MegaDriveROMLoader(const std::wstring& ainstanceName, unsigned int amoduleID)
:Extension(L"MDRomLoader", ainstanceName, amoduleID)
{
	//Create the menu handler
	menuHandler = new FileOpenMenuHandler(this);
}

//----------------------------------------------------------------------------------------
MegaDriveROMLoader::~MegaDriveROMLoader()
{
	//Delete the menu handler
	delete menuHandler;
}

//----------------------------------------------------------------------------------------
//Window functions
//----------------------------------------------------------------------------------------
//##TODO## Shift this into a window source file
void MegaDriveROMLoader::AddFileOpenMenuItems(IMenuSegment& menuSegment, IViewModelLauncher& viewModelLauncher)
{
	Extension::AddFileOpenMenuItems(menuSegment, viewModelLauncher);
	menuHandler->AddMenuItems(menuSegment, viewModelLauncher);
}

//----------------------------------------------------------------------------------------
void MegaDriveROMLoader::LoadROMFile()
{
	//##TODO## Add a path for autogenerated modules to our global preferences?
	std::wstring autoGeneratedROMModuleFolderPath = GetGUIInterface()->GetGlobalPreferencePathModules() + L"\\AutoGenerated";

	//Build a module definition for the target ROM file
	std::wstring romName;
	HeirarchicalStorageTree tree;
	if(!BuildROMFileModule(tree.GetRootNode(), romName))
	{
		return;
	}

	//Generate the file name for the output XML file
	std::wstring moduleFileDir = autoGeneratedROMModuleFolderPath + L"\\" + GetExtensionInstanceName();
	std::wstring moduleFileName = romName + L".xml";

	//Write the generated module structure to the target output file
	if(!SaveOutputROMModule(tree, moduleFileDir, moduleFileName))
	{
		return;
	}

	//Retrieve the current running state of the system, and stop the system if it is
	//currently running.
	ISystemExtensionInterface& system = *GetSystemInterface();
	bool systemRunningState = system.SystemRunning();
	system.StopSystem();

	//If we've managed to generate a module file for the target ROM file successfully,
	//unload any ROM file we might currently have loaded.
	if(romLoaded)
	{
		UnloadROMFile();
		romLoaded = false;
	}

	//Attempt to load the module file we just generated back into the system
	IGUIExtensionInterface& gui = *GetGUIInterface();
	if(!gui.LoadModuleFromFile(moduleFileDir, moduleFileName))
	{
		std::wstring text = L"Failed to load the generated module definition file. Check the event log for further info.";
		std::wstring title = L"Error loading ROM!";
		MessageBox((HWND)GetGUIInterface()->GetMainWindowHandle(), text.c_str(), title.c_str(), MB_ICONEXCLAMATION);
		return;
	}

	//Trigger an initialization of the system now that a new ROM module has been loaded
	system.Initialize();

	//Restore the running state of the system
	if(systemRunningState)
	{
		system.RunSystem();
	}

	//Record information on this loaded module
	romLoaded = true;
	loadedROMModuleFileDir = moduleFileDir;
	loadedROMModuleFileName = moduleFileName;
}

//----------------------------------------------------------------------------------------
bool MegaDriveROMLoader::SaveOutputROMModule(IHeirarchicalStorageTree& tree, const std::wstring& fileDir, const std::wstring& fileName)
{
	//Ensure the target output directory exists
	SHCreateDirectoryEx(NULL, fileDir.c_str(), NULL);

	//Generate a full path for the output file
	std::wstring moduleFilePath = fileDir + L"\\" + fileName;

	//Create the output module file
	Stream::File moduleFile(Stream::IStream::TEXTENCODING_UTF8);
	if(!moduleFile.Open(moduleFilePath, Stream::File::OPENMODE_WRITEONLY, Stream::File::CREATEMODE_CREATE))
	{
		std::wstring text = L"Could not create the output module definition file.";
		std::wstring title = L"Error loading ROM!";
		MessageBox((HWND)GetGUIInterface()->GetMainWindowHandle(), text.c_str(), title.c_str(), MB_ICONEXCLAMATION);
		return false;
	}
	moduleFile.InsertByteOrderMark();

	//Save the generated module XML data to the output module file
	if(!tree.SaveTree(moduleFile))
	{
		std::wstring text = L"Could not save XML structure to output definition file.";
		std::wstring title = L"Error loading ROM!";
		MessageBox((HWND)GetGUIInterface()->GetMainWindowHandle(), text.c_str(), title.c_str(), MB_ICONEXCLAMATION);
		return false;
	}

	//Close the generated module file now that we are finished writing it
	moduleFile.Close();

	return true;
}

//----------------------------------------------------------------------------------------
bool MegaDriveROMLoader::BuildROMFileModule(IHeirarchicalStorageNode& node, std::wstring& romName)
{
	//Get filename
	//##TODO## Add smd, zip, and 7z support.
	TCHAR fileNameBuffer[MAX_PATH];
	OPENFILENAME openFileParams;
	ZeroMemory(&openFileParams, sizeof(openFileParams));
	openFileParams.lStructSize = sizeof(openFileParams);
	openFileParams.hwndOwner = (HWND)GetGUIInterface()->GetMainWindowHandle();
	openFileParams.lpstrFile = fileNameBuffer;
	openFileParams.lpstrFile[0] = '\0';
	openFileParams.nMaxFile = sizeof(fileNameBuffer);
	openFileParams.lpstrFilter = L"Mega Drive ROM file (*.bin;*.gen)\0*.bin;*.gen\0All (*.*)\0*.*\0\0";
	openFileParams.lpstrDefExt = L"gen";
	openFileParams.nFilterIndex = 1;
	openFileParams.lpstrFileTitle = NULL;
	openFileParams.nMaxFileTitle = 0;
	openFileParams.lpstrInitialDir = NULL;
	openFileParams.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
	if(GetOpenFileName(&openFileParams) == 0)
	{
		return false;
	}

	std::wstring fileName = &openFileParams.lpstrFile[openFileParams.nFileOffset];
	std::wstring fileExt = &openFileParams.lpstrFile[openFileParams.nFileExtension];
	PathRemoveFileSpec(openFileParams.lpstrFile);
	std::wstring fileDir = openFileParams.lpstrFile;
	return BuildROMFileModuleFromFile(fileDir, fileName, node, romName);
}

//----------------------------------------------------------------------------------------
bool MegaDriveROMLoader::BuildROMFileModuleFromFile(const std::wstring& fileDir, const std::wstring& fileName, IHeirarchicalStorageNode& node, std::wstring& romName)
{
	//##TODO## Add control over this feature
	bool autoSelectSystemRegion = true;

	//Load the ROM header from the target file
	MegaDriveROMHeader romHeader;
	if(!LoadROMHeaderFromFile(fileDir, fileName, romHeader))
	{
		std::wstring text = L"Could not read ROM header data from file.";
		std::wstring title = L"Error loading ROM!";
		MessageBox((HWND)GetGUIInterface()->GetMainWindowHandle(), text.c_str(), title.c_str(), MB_ICONEXCLAMATION);
		return false;
	}

	//Set the name of this loaded ROM
	romName = fileName;

	//Set all required attributes on the root node for this module definition
	node.SetName(L"Module");
	node.CreateAttribute(L"SystemClassName", L"SegaMegaDrive");
	node.CreateAttribute(L"ModuleClassName", fileName);
	node.CreateAttribute(L"ModuleInstanceName", fileName);
	node.CreateAttribute(L"ProgramModule", true);

	//Determine the size of the ROM region to allocate. We use the ROM file size rather
	//than the recorded ROM region in the file header, since this information is
	//essentially unused, and may be incorrect, especially for homebrew ROM files.
	unsigned int romRegionSize = romHeader.fileSize;

	//Add all required child elements for this module definition
	node.CreateChild(L"System.ImportConnector").CreateAttribute(L"ConnectorClassName", L"CartridgePort").CreateAttribute(L"ConnectorInstanceName", L"Cartridge Port");
	node.CreateChild(L"System.ImportBusInterface").CreateAttribute(L"ConnectorInstanceName", L"Cartridge Port").CreateAttribute(L"BusInterfaceName", L"BusInterface").CreateAttribute(L"ImportName", L"BusInterface");
	node.CreateChild(L"System.ImportSystemLine").CreateAttribute(L"ConnectorInstanceName", L"Cartridge Port").CreateAttribute(L"SystemLineName", L"CART").CreateAttribute(L"ImportName", L"CART");
	node.CreateChild(L"Device").CreateAttribute(L"DeviceName", L"ROM").CreateAttribute(L"InstanceName", L"ROM").CreateAttribute(L"BinaryDataPresent", true).CreateAttribute(L"SeparateBinaryData", true).SetData(fileDir + L"\\" + fileName);
	node.CreateChild(L"BusInterface.MapDevice").CreateAttribute(L"BusInterfaceName", L"BusInterface").CreateAttribute(L"DeviceInstanceName", L"ROM").CreateAttribute(L"CELineConditions", L"FCCPUSpace=0, CE0=1").CreateAttributeHex(L"MemoryMapBase", 0, 6).CreateAttributeHex(L"MemoryMapSize", romRegionSize, 6);
	node.CreateChild(L"System.SetLineState").CreateAttribute(L"SystemLineName", L"CART").CreateAttribute(L"Value", 1);

	//If automatic selection of the preferred compatible system region is enabled for
	//games that require specific region codes, attempt to detect the region now, and
	//output region selection elements to the module definition.
	if(autoSelectSystemRegion)
	{
		//Attempt to auto-detect the compatible system region based on the region header
		bool specificRegionCodeDetected = false;
		std::wstring regionCode;
		bool regionCodePresentJ = (romHeader.regionString.find('J') != std::string::npos);
		bool regionCodePresentU = (romHeader.regionString.find('U') != std::string::npos);
		bool regionCodePresentE = (romHeader.regionString.find('E') != std::string::npos);
		if(regionCodePresentJ && regionCodePresentU && regionCodePresentE)
		{
			//If this ROM is marked as compatible with all regions, don't change the
			//system region setting.
		}
		else if(regionCodePresentU)
		{
			regionCode = L"U";
			specificRegionCodeDetected = true;
		}
		else if(regionCodePresentE)
		{
			regionCode = L"E";
			specificRegionCodeDetected = true;
		}
		else if(regionCodePresentJ)
		{
			regionCode = L"J";
			specificRegionCodeDetected = true;
		}

		//If we detected that this ROM requires a specific region code, add a settings
		//change to apply that region code setting automatically.
		if(specificRegionCodeDetected)
		{
			node.CreateChild(L"System.ImportSystemSetting").CreateAttribute(L"ConnectorInstanceName", L"Cartridge Port").CreateAttribute(L"SystemSettingName", L"Region").CreateAttribute(L"ImportName", L"Region");
			node.CreateChild(L"System.SelectSettingOption").CreateAttribute(L"SettingName", L"Region").CreateAttribute(L"OptionName", regionCode);
		}
	}

	return true;
}

//----------------------------------------------------------------------------------------
bool MegaDriveROMLoader::LoadROMHeaderFromFile(const std::wstring& fileDir, const std::wstring& fileName, MegaDriveROMHeader& romHeader) const
{
	//Open the target ROM file
	Stream::File file;
	if(!file.Open(fileDir + L'\\' + fileName, Stream::File::OPENMODE_READONLY, Stream::File::CREATEMODE_OPEN))
	{
		return false;
	}

	//Validate the size of the selected file
	if(file.Size() < 0x200)
	{
		return false;
	}

	//Read in the contents of the Mega Drive ROM header from the file
	file.SetStreamPos(0x100);
	bool result = true;
	result &= file.ReadTextFixedLengthBufferAsASCII(0x10, romHeader.segaString);
	result &= file.ReadTextFixedLengthBufferAsASCII(0x10, romHeader.copyrightString);
	result &= file.ReadTextFixedLengthBufferAsASCII(0x30, romHeader.gameTitleJapan);
	result &= file.ReadTextFixedLengthBufferAsASCII(0x30, romHeader.gameTitleOverseas);
	result &= file.ReadTextFixedLengthBufferAsASCII(0x0E, romHeader.versionString);
	result &= file.ReadDataBigEndian(romHeader.checksum);
	result &= file.ReadTextFixedLengthBufferAsASCII(0x10, romHeader.controllerString);
	result &= file.ReadDataBigEndian(romHeader.romLocationStart);
	result &= file.ReadDataBigEndian(romHeader.romLocationEnd);
	result &= file.ReadDataBigEndian(romHeader.ramLocationStart);
	result &= file.ReadDataBigEndian(romHeader.ramLocationEnd);
	result &= file.ReadTextFixedLengthBufferAsASCII(0x40, romHeader.unknownString);
	result &= file.ReadTextFixedLengthBufferAsASCII(0x10, romHeader.regionString);

	//Record additional information about the ROM file
	romHeader.fileSize = (unsigned int)file.Size();

	//Return the result of the operation
	return result;
}

//----------------------------------------------------------------------------------------
void MegaDriveROMLoader::UnloadROMFile()
{
	//If this ROM file is currently loaded, unload it.
	if(romLoaded)
	{
		//Unload all matching modules
		bool done = false;
		while(!done)
		{
			//Retrieve the set of ID numbers for all currently loaded modules
			std::list<unsigned int> loadedModuleIDs = GetSystemInterface()->GetLoadedModuleIDs();

			//Attempt to retrieve the ID of the next matching loaded module file
			bool foundLoadedModuleID = false;
			unsigned int loadedModuleID;
			std::list<unsigned int>::const_iterator loadedModuleIDIterator = loadedModuleIDs.begin();
			while(!foundLoadedModuleID && (loadedModuleIDIterator != loadedModuleIDs.end()))
			{
				LoadedModuleInfo moduleInfo;
				if(GetSystemInterface()->GetLoadedModuleInfo(*loadedModuleIDIterator, moduleInfo))
				{
					if((moduleInfo.GetModuleFileDirectory() == loadedROMModuleFileDir) && (moduleInfo.GetModuleFileName() == loadedROMModuleFileName))
					{
						foundLoadedModuleID = true;
						loadedModuleID = moduleInfo.GetModuleID();
					}
				}
				++loadedModuleIDIterator;
			}

			//If we managed to locate the module file, unload it.
			if(foundLoadedModuleID)
			{
				GetGUIInterface()->UnloadModule(loadedModuleID);
			}

			//If we failed to find any more matching target modules, flag that we've completed
			//the operation.
			done = !foundLoadedModuleID;
		}

		//Flag that this ROM file is no longer loaded
		romLoaded = false;
	}
}
